<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="dark">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Matryoshka Crackme Write-up | Schnee | Software Security</title>
<meta name="keywords" content="">
<meta name="description" content="Reverse-engineering write-up of the Matryoshka crackme, focusing on its in-memory ELF loader using memfd_create and execve.
">
<meta name="author" content="">
<link rel="canonical" href="https://schnee.re/posts/matryoshka/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://schnee.re/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://schnee.re/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://schnee.re/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://schnee.re/apple-touch-icon.png">
<link rel="mask-icon" href="https://schnee.re/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://schnee.re/posts/matryoshka/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://schnee.re/posts/matryoshka/">
  <meta property="og:site_name" content="Schnee | Software Security">
  <meta property="og:title" content="Matryoshka Crackme Write-up">
  <meta property="og:description" content="Reverse-engineering write-up of the Matryoshka crackme, focusing on its in-memory ELF loader using memfd_create and execve.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-06T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-06T00:00:00+00:00">
      <meta property="og:image" content="https://schnee.re/posts/matryoshka/cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://schnee.re/posts/matryoshka/cover.png">
<meta name="twitter:title" content="Matryoshka Crackme Write-up">
<meta name="twitter:description" content="Reverse-engineering write-up of the Matryoshka crackme, focusing on its in-memory ELF loader using memfd_create and execve.
">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://schnee.re/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Matryoshka Crackme Write-up",
      "item": "https://schnee.re/posts/matryoshka/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Matryoshka Crackme Write-up",
  "name": "Matryoshka Crackme Write-up",
  "description": "Reverse-engineering write-up of the Matryoshka crackme, focusing on its in-memory ELF loader using memfd_create and execve.\n",
  "keywords": [
    
  ],
  "articleBody": "Infos Author: iamwololo Crackme Link: https://crackmes.one/crackme/68ff42b82d267f28f69b78c8 Platform: ELF x64 Difficulty: 2.4 (crackmes.one rating) Tools Used: IDA Introduction This write-up analyzes the Matryoshka crackme from crackmes.one. The challenge implements a multi-stage in-memory ELF loader using memfd_create and execve, with each stage decrypted via a simple XOR.\nThe goal is to recover the correct input that eventually triggers the final stage to print “u win good job!!!”.\nInitial Reconnaissance As always, we’ll first run the strings command: Most of the syscalls look familiar, the only one I’d have to look up was memfd_create. Turns out it is a neat syscall to create a file in RAM, removing it once all references to the fd are closed.\nLooking at the name “Matryoshka”, which suggests something with many layers, and knowing that we’ll be running “execve” and writing to a file in RAM, I would guess that we’ll have a binary blob somewhere we’ll be executing.\nLet’s find out and continue with our static analysis.\nStatic Analysis | IDA After renaming the relevant functions and variables our main functions looks like following:\n__int64 __fastcall main(int argc, char **argv, char **env) { char xorValue; // [rsp+1Fh] [rbp-21h] char *newArgv[4]; // [rsp+20h] [rbp-20h] BYREF newArgv[3] = (char *)__readfsqword(0x28u); if ( argc == 2 ) { xorValue = *argv[1] - 87; newArgv[0] = (char *)\u0026unk_201C; newArgv[1] = argv[1] + 1; if ( mainLogic(\u0026binBlob, binSize, xorValue, newArgv) == -1 ) useless(); return 0; } else { puts(\"usage: ./matryoshka key\"); return 0; } } As we can see the mainLogic function takes 4 arguments, first the binary blob, secondly the binary size, third the xorValue (which is the first char of the input - 87) and the new argv (where the input moved one char to the right).\nThe mainLogic function has three main functions:\nint __fastcall mainLogic(const void *binBlob, unsigned int blobSize, char xorValue, char *const *newArgv) { FILE *fd; // [rsp+28h] [rbp-8h] xorBlob((__int64)binBlob, blobSize, xorValue); fd = createWriteFile(binBlob, blobSize, 1u); return executeFdWithExecve(fd, (__int64)\u0026unk_201D, newArgv); } as you can see there are 3 relevant functions:\nxorBlob: simple xor function, the binary blob gets xored with the xorValue createWriteFile: we create a file from the binary blob with the mentioned syscall memfd_create executeFdWIthExecve: we execute the binary blob with execve and the new argv I won’t go into detail about those three functions, since they basically do as described above. Since we now know the high level structure of the program, let’s see how we can get the correct xor value/input.\nGetting correct Input Since execve requires a valid ELF file, the correct XOR key must produce the ELF magic bytes (0x7f 45 4c 46) at the beginning of the decrypted blob. With that information I wrote a script bruteforcing the XOR key. Since I’m trying to get used to the IDA api, I decided to write an IDA python script for the challenge:\nimport ida_bytes import ida_name import ida_idaapi blob = 0x4080 size = ida_bytes.get_dword( ida_name.get_name_ea(ida_idaapi.BADADDR, \"dword_EA60\") ) data = ida_bytes.get_bytes(blob, size) def xor(data, k): return bytes(b ^ (k \u0026 0xff) for b in data) KEY = None for k in range(-128, 128): dec = xor(data, k) head = dec[:0x200] if b\"\\x7fELF\" in head: off = head.index(b\"\\x7fELF\") KEY = k print(k) break if KEY is None: raise RuntimeError(\"Key not found\") OUT = \"/tmp/matryoshka_stage.bin\" dec = bytes(b ^ (KEY \u0026 0xff) for b in data) with open(OUT, \"wb\") as f: f.write(dec) The script sucessfully executed and we’ve just found our first char Input, “f”.\nIt turns out, the next 2 characters are obtained the same way, the structure of the new binary is exactly the same, apart from the xor key.\nSo we run our script again and get the next 2 characters, “b3”.\nThe last binary is a simply atoi which converts the input and checks if it’s “9”: Conclusion Even though there was no anti debugging nor obfuscation involved I enjoyed the challenge, especially since it gave me the opportunity to do some IDA scripting.\nfinal key: “fb39”\n",
  "wordCount" : "661",
  "inLanguage": "en",
  "image": "https://schnee.re/posts/matryoshka/cover.png","datePublished": "2026-01-06T00:00:00Z",
  "dateModified": "2026-01-06T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://schnee.re/posts/matryoshka/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Schnee | Software Security",
    "logo": {
      "@type": "ImageObject",
      "url": "https://schnee.re/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://schnee.re/" accesskey="h" title="Schnee | Software Security (Alt + H)">Schnee | Software Security</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://schnee.re/">Home</a>&nbsp;»&nbsp;<a href="https://schnee.re/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Matryoshka Crackme Write-up
    </h1>
    <div class="post-description">
      Reverse-engineering write-up of the Matryoshka crackme, focusing on its in-memory ELF loader using memfd_create and execve.

    </div>
    <div class="post-meta"><span title='2026-01-06 00:00:00 +0000 UTC'>January 6, 2026</span>&nbsp;·&nbsp;<span>4 min</span>

</div>
  </header> 
  <div class="post-content"><h2 id="infos">Infos<a hidden class="anchor" aria-hidden="true" href="#infos">#</a></h2>
<ul>
<li><strong>Author: iamwololo</strong></li>
<li><strong>Crackme Link: <a href="https://crackmes.one/crackme/68ff42b82d267f28f69b78c8">https://crackmes.one/crackme/68ff42b82d267f28f69b78c8</a></strong></li>
<li><strong>Platform: ELF x64</strong></li>
<li><strong>Difficulty: 2.4 (crackmes.one rating)</strong></li>
<li><strong>Tools Used: IDA</strong></li>
</ul>
<hr>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>This write-up analyzes the <em>Matryoshka</em> crackme from crackmes.one.
The challenge implements a multi-stage in-memory ELF loader using
<code>memfd_create</code> and <code>execve</code>, with each stage decrypted via a simple XOR.</p>
<p>The goal is to recover the correct input that eventually triggers the
final stage to print “u win good job!!!”.</p>
<hr>
<h2 id="initial-reconnaissance">Initial Reconnaissance<a hidden class="anchor" aria-hidden="true" href="#initial-reconnaissance">#</a></h2>
<p>As always, we&rsquo;ll first run the strings command:
<img alt="strings" loading="lazy" src="/posts/matryoshka/strings.png"></p>
<p>Most of the syscalls look familiar, the only one I&rsquo;d have to look up was <em>memfd_create</em>. Turns out it is a neat syscall to create a file in RAM, removing it once all references to the fd are closed.</p>
<p>Looking at the name &ldquo;Matryoshka&rdquo;, which suggests something with many layers, and knowing that we&rsquo;ll be running &ldquo;execve&rdquo; and writing to a file in RAM, I would guess that we&rsquo;ll have a binary blob somewhere we&rsquo;ll be executing.</p>
<p>Let&rsquo;s find out and continue with our static analysis.</p>
<h3 id="static-analysis--ida">Static Analysis | IDA<a hidden class="anchor" aria-hidden="true" href="#static-analysis--ida">#</a></h3>
<p>After renaming the relevant functions and variables our main functions looks like following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>env)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> xorValue; <span style="color:#75715e">// [rsp+1Fh] [rbp-21h]
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>newArgv[<span style="color:#ae81ff">4</span>]; <span style="color:#75715e">// [rsp+20h] [rbp-20h] BYREF
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  newArgv[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">__readfsqword</span>(<span style="color:#ae81ff">0x28u</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( argc <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    xorValue <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>argv[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">87</span>;
</span></span><span style="display:flex;"><span>    newArgv[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>unk_201C;
</span></span><span style="display:flex;"><span>    newArgv[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">mainLogic</span>(<span style="color:#f92672">&amp;</span>binBlob, binSize, xorValue, newArgv) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> )
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">useless</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;usage: ./matryoshka key&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As we can see the <strong>mainLogic</strong> function takes 4 arguments, first the binary blob, secondly the binary size, third the xorValue (which is the first char of the input - 87) and the new argv (where the input moved one char to the right).</p>
<p>The mainLogic function has three main functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">mainLogic</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>binBlob, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> blobSize, <span style="color:#66d9ef">char</span> xorValue, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>newArgv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  FILE <span style="color:#f92672">*</span>fd; <span style="color:#75715e">// [rsp+28h] [rbp-8h]
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">xorBlob</span>((<span style="color:#66d9ef">__int64</span>)binBlob, blobSize, xorValue);
</span></span><span style="display:flex;"><span>  fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">createWriteFile</span>(binBlob, blobSize, <span style="color:#ae81ff">1u</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">executeFdWithExecve</span>(fd, (<span style="color:#66d9ef">__int64</span>)<span style="color:#f92672">&amp;</span>unk_201D, newArgv);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>as you can see there are 3 relevant functions:</p>
<ul>
<li><strong>xorBlob:</strong> simple xor function, the binary blob gets xored with the xorValue</li>
<li><strong>createWriteFile:</strong> we create a file from the binary blob with the mentioned syscall <em>memfd_create</em></li>
<li><strong>executeFdWIthExecve:</strong> we execute the binary blob with execve and the new argv</li>
</ul>
<p>I won&rsquo;t go into detail about those three functions, since they basically do as described above.
Since we now know the high level structure of the program, let&rsquo;s see how we can get the correct xor value/input.</p>
<h3 id="getting-correct-input">Getting correct Input<a hidden class="anchor" aria-hidden="true" href="#getting-correct-input">#</a></h3>
<p>Since execve requires a valid ELF file, the correct XOR key must
produce the ELF magic bytes (0x7f 45 4c 46) at the beginning of the
decrypted blob. With that information I wrote a script bruteforcing the XOR key.
Since I&rsquo;m trying to get used to the IDA api, I decided to write an IDA python script for the challenge:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> ida_bytes
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> ida_name
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> ida_idaapi
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>blob <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4080</span>
</span></span><span style="display:flex;"><span>size <span style="color:#f92672">=</span> ida_bytes<span style="color:#f92672">.</span>get_dword(
</span></span><span style="display:flex;"><span>    ida_name<span style="color:#f92672">.</span>get_name_ea(ida_idaapi<span style="color:#f92672">.</span>BADADDR, <span style="color:#e6db74">&#34;dword_EA60&#34;</span>)
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> ida_bytes<span style="color:#f92672">.</span>get_bytes(blob, size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">xor</span>(data, k):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> bytes(b <span style="color:#f92672">^</span> (k <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>KEY <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#f92672">-</span><span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">128</span>):
</span></span><span style="display:flex;"><span>    dec <span style="color:#f92672">=</span> xor(data, k)
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> dec[:<span style="color:#ae81ff">0x200</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x7f</span><span style="color:#e6db74">ELF&#34;</span> <span style="color:#f92672">in</span> head:
</span></span><span style="display:flex;"><span>        off <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>index(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x7f</span><span style="color:#e6db74">ELF&#34;</span>)
</span></span><span style="display:flex;"><span>        KEY <span style="color:#f92672">=</span> k
</span></span><span style="display:flex;"><span>        print(k)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> KEY <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">RuntimeError</span>(<span style="color:#e6db74">&#34;Key not found&#34;</span>)
</span></span><span style="display:flex;"><span>OUT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/tmp/matryoshka_stage.bin&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dec <span style="color:#f92672">=</span> bytes(b <span style="color:#f92672">^</span> (KEY <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(OUT, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(dec)
</span></span></code></pre></div><p>The script sucessfully executed and we&rsquo;ve just found our first char Input, &ldquo;f&rdquo;.</p>
<p>It turns out, the next 2 characters are obtained the same way, the structure of the new binary is exactly the same, apart from the xor key.</p>
<p>So we run our script again and get the next 2 characters, &ldquo;b3&rdquo;.</p>
<p>The last binary is a simply atoi which converts the input and checks if it&rsquo;s &ldquo;9&rdquo;:
<img alt="final_binary" loading="lazy" src="/posts/matryoshka/final_binary.png"></p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Even though there was no anti debugging nor obfuscation involved I enjoyed the challenge, especially since it gave me the opportunity to do some IDA scripting.</p>
<p>final key: &ldquo;fb39&rdquo;</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://schnee.re/">Schnee | Software Security</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
